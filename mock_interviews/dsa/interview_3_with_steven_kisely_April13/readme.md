## Questions Asked
1. https://leetcode.com/problems/rotting-oranges/description/
2. https://leetcode.com/problems/decode-string/description/
3. Codebunk
   1. https://codebunk.com/b/7111100709477/

### Feedback from conversation
1. If you can think of brute force solution, say it first and then iterate for a better approach.
2. Always write sudo code while explaining, this will ensure you get the logic correct and even if you are stuck while implementing, you can always look back at sudo code.
3. When doing a dry run, always add comments on the variables to show how the variable values changes.

### Feedback from IK portal
```
Topics Covered
Arrays,Strings
Problem Text
Given a 2D grid, each cell contains a human 0, zombie 1, or wall 2 (numbers 0, 1, 2). Zombies can turn adjacent (up/down/left/right) human beings into zombies every day, but cannot go through walls. How long will it take to turn all people into zombies? Return -1 if not all humans are turned into zombies.
Difficulty
Medium
Understanding
4 — The candidate quickly and clearly understood the problem, with little to no resistance in processing what was being asked.
Working Solution Proposed
4 — The candidate arrived at a working solution that addressed all problem requirements and covered all possible edge cases. Well done.
Optimized Solution Proposed
4 — The solution was a beast. Not only was it maximally performant and algorithmically/logically appropriate, but it was elegant on a whole other level.
Implementation
4 — The solution was fully implemented in code, with all bases covered meticulously.
Was a second problem attempted?
Yes
Problem Text
Given an encoded string, return its decoded string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. You may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won't be input like 3a or 2[4] Input will always be valid and consists of lowercase english letters, digits, and square brackets [ ]
Difficulty
Medium
Understanding
4 — The candidate quickly and clearly understood the problem, with little to no resistance in processing what was being asked.
Working Solution Proposed
4 — The candidate arrived at a working solution that addressed all problem requirements and covered all possible edge cases. Well done.
Optimized Solution Proposed
4 — The solution was a beast. Not only was it maximally performant and algorithmically/logically appropriate, but it was elegant on a whole other level.
Implementation
4 — The solution was fully implemented in code, with all bases covered meticulously.
Was a third problem attempted?
No
Brush-Up on Specific Topics
None, but always be practicing
Verbal Explanation
4 — The candidate is exceptionally talented at crisply revealing their thinking around each solution, which kept the interviewer in sync with their perspectives throughout the process.
Hints Needed
3 — Hints were given, but well within the range of acceptable both in number and significance. A real-world interviewer would still see the solution as an achievement of the candidate.
Hints Utilized
4 — The candidate heard, understood, and made maximal use of all hints given.
Amount & Severity of Bugs
4 — No bugs detected. Code was flawless. Extremely well done!
Debugging
4 — The candidate was able to both identify and fix all bugs on their own with negligible assistance from the interviewer.
Time & Space Complexity
4 — The candidate had a nuanced grasp of time and space complexity and was able to articulate their understanding crisply and quickly.
Code Readability
4 — The code was exquisitely readable. Variable and function names were clear and sensible. Logic was abstracted into highly digestible chunks.
Language Comfort
4 — The candidate is masterfully fluent with their programming language. They rapidly translated their solution into code and did so in a way that suggests deep and nuanced understanding of language-specific features and style.
Communication
4 — Communication was a joy. It was effortless for the interviewer to understand what the candidate was saying. Explanations were often especially nuanced and crisp.
Humility
4 — The candidate demonstrated exceptional humility. At no point could it even be possible to mistake this person as arrogant. It was a pleasure to engage with them.
Energy
4 — The candidate's energy was palpably high. They were positive, action-oriented, and/or beaming with enthusiastic energy at various points in the interview, if not throughout. They would have the effect of lifting the energy of the entire team if hired.
Interview Anxiety
4 — No nervousness was detected at all. The candidate was very much at ease and/or highly confident.
Technical Score
4 — The candidate's technical performance was stellar. They made smooth progress through the problem, code was fluent, and testing was second nature. The interviewer may even have learned something from their solution. Strong hire.
Behavioral Score
4 — This person was a pleasure to engage with. They demonstrate exemplary maturity and humility. Questions asked are pertinent, conversation is inspirational. The interviewer is excited by the prospect of working with the candidate.
Hire Decision
Yes
Candidate Strengths
- good job asking clarifying questions - Excellent job explaining your thinking - code is clean and readable
Additional Feedback
General tips: - If you’re not positive about how to solve the problem, I always recommend doing small examples of the problem. This will help you understand the problem, identify edge cases, and create your algorithm. - I always recommend writing pseudocode while working through example problems. This will help you code faster. It also protects you because if you become confused, you can refer back to it. - I always recommend calling out brute-force solutions as you see them. Take a few minutes and try to find a better solution, but if you can’t find one, you can code the brute-force one. Remember, a working solution is better than no solution. It is also likely along the way you may find a better solution, or the interviewer will give a hint. - When you do your debug walkthrough, add comments at the end of each line showing how the variables update. This forces you to go line by line and will help you find bugs. You can write any larger data structures nearby and update them as you go. - It’s okay to go silent and think. Just make sure you go back and pull the interviewer in. You can say, “So what I am thinking is” or “This piece of code does.” You did very well. Keep practicing, and I am confident you'll do well.
```